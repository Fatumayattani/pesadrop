"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HederaGetTopicMessagesTool = exports.HederaGetTopicInfoTool = exports.HederaSubmitTopicMessageTool = exports.HederaDeleteTopicTool = exports.HederaCreateTopicTool = exports.HederaGetTokenHoldersTool = exports.HederaGetAllTokenBalancesTool = exports.HederaGetPendingAirdropTool = exports.HederaClaimAirdropTool = exports.HederaMintNFTTool = exports.HederaTransferHbarTool = exports.HederaMintFungibleTokenTool = exports.HederaRejectTokenTool = exports.HederaDissociateTokenTool = exports.HederaAssociateTokenTool = exports.HederaAirdropTokenTool = exports.HederaGetHtsBalanceTool = exports.HederaGetBalanceTool = exports.HederaTransferTokenTool = exports.HederaCreateNonFungibleTokenTool = exports.HederaCreateFungibleTokenTool = void 0;
exports.createHederaTools = createHederaTools;
const tools_1 = require("@langchain/core/tools");
const dotenv = __importStar(require("dotenv"));
const sdk_1 = require("@hashgraph/sdk");
dotenv.config();
class HederaCreateFungibleTokenTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_create_fungible_token';
        this.description = `Create a fungible token on Hedera
Inputs ( input is a JSON string ):
name: string, the name of the token e.g. My Token,
symbol: string, the symbol of the token e.g. MT,
decimals: number, the amount of decimals of the token,
initialSupply: number, the initial supply of the token e.g. 100000,
isSupplyKey: boolean, decides whether supply key should be set, false if not passed
isMetadataKey: boolean, decides whether metadata key should be set, false if not passed
isAdminKey: boolean, decides whether admin key should be set, false if not passed
memo: string, containing memo associated with this token, empty string if not passed
tokenMetadata: string, containing metadata associated with this token, empty string if not passed
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const tokenId = (await this.hederaKit.createFT({
                name: parsedInput.name,
                symbol: parsedInput.symbol,
                decimals: parsedInput.decimals,
                initialSupply: parsedInput.initialSupply,
                isSupplyKey: parsedInput.isSupplyKey,
                isAdminKey: parsedInput.isAdminKey,
                isMetadataKey: parsedInput.isMetadataKey,
                memo: parsedInput.memo,
                tokenMetadata: new TextEncoder().encode(parsedInput.tokenMetadata),
            })).tokenId;
            return JSON.stringify({
                status: "success",
                message: "Token creation successful",
                initialSupply: parsedInput.initialSupply,
                tokenId: tokenId.toString(),
                solidityAddress: tokenId.toSolidityAddress(),
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaCreateFungibleTokenTool = HederaCreateFungibleTokenTool;
// FIXME: works well in isolation but normally usually createFT is called instead of createNFT
class HederaCreateNonFungibleTokenTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_create_fungible_token';
        this.description = `Create a non fungible (NFT) token on Hedera
Inputs ( input is a JSON string ):
name: string, the name of the token e.g. My Token,
symbol: string, the symbol of the token e.g. MT,
maxSupply: number, the max supply of the token e.g. 100000,
isMetadataKey: boolean, decides whether metadata key should be set, false if not passed
isAdminKey: boolean, decides whether admin key should be set, false if not passed
memo: string, containing memo associated with this token, empty string if not passed
tokenMetadata: string, containing metadata associated with this token, empty string if not passed
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const tokenId = (await this.hederaKit.createNFT({
                name: parsedInput.name,
                symbol: parsedInput.symbol,
                maxSupply: parsedInput.maxSupply,
                isAdminKey: parsedInput.isAdminKey,
                isMetadataKey: parsedInput.isMetadataKey,
                memo: parsedInput.memo,
                tokenMetadata: new TextEncoder().encode(parsedInput.tokenMetadata),
            })).tokenId;
            return JSON.stringify({
                status: "success",
                message: "NFT Token creation successful",
                initialSupply: parsedInput.initialSupply,
                tokenId: tokenId.toString(),
                solidityAddress: tokenId.toSolidityAddress(),
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaCreateNonFungibleTokenTool = HederaCreateNonFungibleTokenTool;
class HederaTransferTokenTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_transfer_token';
        this.description = `Transfer fungible tokens on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of the token to transfer e.g. 0.0.123456,
toAccountId: string, the account ID to transfer to e.g. 0.0.789012,
amount: number, the amount of tokens to transfer e.g. 100
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.transferToken(parsedInput.tokenId, parsedInput.toAccountId, parsedInput.amount);
            return JSON.stringify({
                status: "success",
                message: "Token transfer successful",
                tokenId: parsedInput.tokenId,
                toAccountId: parsedInput.toAccountId,
                amount: parsedInput.amount
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaTransferTokenTool = HederaTransferTokenTool;
class HederaGetBalanceTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_get_hbar_balance';
        this.description = `Retrieves the HBAR balance of a specified Hedera account.  
If an account ID is provided, it returns the balance of that account.  
If no input is given (empty JSON '{}'), it returns the balance of the connected account.  

### **Inputs** (optional, input is a JSON string):  
- **accountId** (*string*, optional): The Hedera account ID to check the balance for (e.g., "0.0.789012").  
  - If omitted, the tool will return the balance of the connected account.  

### **Example Usage:**  
1. **Get balance of a specific account:**  
   '{ "accountId": "0.0.123456" }'  
2. **Get balance of the connected account:**  
   '{}'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const balance = await this.hederaKit.getHbarBalance(parsedInput?.accountId);
            return JSON.stringify({
                status: "success",
                balance: balance,
                unit: "HBAR"
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaGetBalanceTool = HederaGetBalanceTool;
class HederaGetHtsBalanceTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_get_hts_balance';
        this.description = `Retrieves the balance of a specified Hedera Token Service (HTS) token for a given account.  
If an account ID is provided, it returns the balance of that account.  
If no account ID is given, it returns the balance for the connected account.

### **Inputs** (JSON string, required fields specified):  
- **tokenId** (*string*, required): The ID of the token to check the balance for (e.g., "0.0.112233").  
- **accountId** (*string*, optional): The Hedera account ID to check the balance for (e.g., "0.0.789012").  
  - If omitted, the tool will return the balance for the connected account.


### **Example Usage:**  
1. **Get balance of token 0.0.112233 for account "0.0.123456:**  
   '{ "accountId": "0.0.123456", "tokenId":"0.0.112233"}'  
2. **Get balance of of token 0.0.11223 for the connected account:**  
   '{"tokenId":"0.0.112233"}'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            if (!parsedInput.tokenId) {
                throw new Error("tokenId is required");
            }
            if (!process.env.HEDERA_NETWORK) {
                throw new Error("HEDERA_NETWORK environment variable is required");
            }
            const balance = await this.hederaKit.getHtsBalance(parsedInput.tokenId, process.env.HEDERA_NETWORK, parsedInput?.accountId);
            const details = await this.hederaKit.getHtsTokenDetails(parsedInput?.tokenId, process.env.HEDERA_NETWORK);
            return JSON.stringify({
                status: "success",
                balance: balance,
                unit: details.symbol
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaGetHtsBalanceTool = HederaGetHtsBalanceTool;
class HederaAirdropTokenTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_airdrop_token';
        this.description = `Airdrop fungible tokens to multiple accounts on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of the token to airdrop e.g. 0.0.123456,
recipients: array of objects containing:
  - accountId: string, the account ID to send tokens to e.g. 0.0.789012
  - amount: number, the amount of tokens to send e.g. 100
Example usage:
1. Airdrop 100 tokens to account 0.0.789012 and 200 tokens to account 0.0.789013:
  '{
    "tokenId": "0.0.123456",
    "recipients": [
    {"accountId": "0.0.789012", "amount": 100},
    {"accountId": "0.0.789013", "amount": 200}
  ]
}'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.airdropToken(parsedInput.tokenId, parsedInput.recipients);
            return JSON.stringify({
                status: "success",
                message: "Token airdrop successful",
                tokenId: parsedInput.tokenId,
                recipientCount: parsedInput.recipients.length,
                totalAmount: parsedInput.recipients.reduce((sum, r) => sum + r.amount, 0)
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaAirdropTokenTool = HederaAirdropTokenTool;
class HederaAssociateTokenTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_associate_token';
        this.description = `Associate a token to an account on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of thee token to associate e.g. 0.0.123456,
Example usage:
1. Associate token 0.0.123456:
  '{
    "tokenId": "0.0.123456"
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.associateToken(parsedInput.tokenId);
            return JSON.stringify({
                status: "success",
                message: "Token association successful",
                tokenId: parsedInput.tokenId
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaAssociateTokenTool = HederaAssociateTokenTool;
class HederaDissociateTokenTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_dissociate_token';
        this.description = `Dissociate a token from an account on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of the token to dissociate e.g. 0.0.123456,
Example usage:
1. Dissociate token 0.0.123456:
  '{
    "tokenId": "0.0.123456"
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.dissociateToken(parsedInput.tokenId);
            return JSON.stringify({
                status: "success",
                message: "Token dissociation successful",
                tokenId: parsedInput.tokenId
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaDissociateTokenTool = HederaDissociateTokenTool;
class HederaRejectTokenTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_reject_token';
        this.description = `Reject a token from an account on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of the token to reject e.g. 0.0.123456,
Example usage:
1. Reject token 0.0.123456:
  '{
    "tokenId": "0.0.123456"
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.rejectToken(sdk_1.TokenId.fromString(parsedInput.tokenId));
            return JSON.stringify({
                status: "success",
                message: "Token rejection successful",
                tokenId: parsedInput.tokenId
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaRejectTokenTool = HederaRejectTokenTool;
class HederaMintFungibleTokenTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_mint_fungible_token';
        this.description = `Mint fungible tokens to an account on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of the token to mint e.g. 0.0.123456,
amount: number, the amount of tokens to mint e.g. 100,
Example usage:
1. Mint 100 of token 0.0.123456 to account 0.0.789012:
  '{
    "tokenId": "0.0.123456",
    "amount": 100
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.mintToken(parsedInput.tokenId, parsedInput.amount);
            return JSON.stringify({
                status: "success",
                message: "Token minting successful",
                tokenId: parsedInput.tokenId,
                amount: parsedInput.amount
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaMintFungibleTokenTool = HederaMintFungibleTokenTool;
class HederaTransferHbarTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_transfer_hbar';
        this.description = `Transfer HBAR to an account on Hedera
Inputs ( input is a JSON string ):
toAccountId: string, the account ID to transfer to e.g. 0.0.789012,
amount: number, the amount of HBAR to transfer e.g. 100,
Example usage:
1. Transfer 100 HBAR to account 0.0.789012:
  '{
    "toAccountId": "0.0.789012",
    "amount": 100
  }'
`;
    }
    async _call(input) {
        try {
            console.log(input);
            const parsedInput = JSON.parse(input);
            await this.hederaKit.transferHbar(parsedInput.toAccountId, parsedInput.amount);
            return JSON.stringify({
                status: "success",
                message: "HBAR transfer successful",
                toAccountId: parsedInput.toAccountId,
                amount: parsedInput.amount
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaTransferHbarTool = HederaTransferHbarTool;
class HederaMintNFTTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_mint_nft';
        this.description = `Mint an NFT to an account on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of the token to mint e.g. 0.0.123456,
tokenMetadata: string, the metadata of the NFT e.g. "My NFT",
Example usage:
1. Mint an NFT with metadata "My NFT" to token 0.0.123456:
  '{
    "tokenId": "0.0.123456",
    "tokenMetadata": "My NFT"
  }
}
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.mintNFTToken(parsedInput.tokenId, parsedInput.tokenMetadata);
            return JSON.stringify({
                status: "success",
                message: "NFT minting successful",
                tokenId: parsedInput.tokenId,
                tokenMetadata: parsedInput.tokenMetadata
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaMintNFTTool = HederaMintNFTTool;
class HederaClaimAirdropTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_claim_airdrop';
        this.description = `Claim an airdrop for a token on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of the token to claim the airdrop for e.g. 0.0.123456,
senderAccountId: string, the account ID of the sender e.g. 0.0.789012,
Example usage:
1. Claim an airdrop for token 0.0.123456 from account 0.0.789012:
  '{
    "tokenId": "0.0.123456",
    "senderAccountId": "0.0.789012"
  }
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const airdropId = new sdk_1.PendingAirdropId({
                tokenId: sdk_1.TokenId.fromString(parsedInput.tokenId),
                senderId: sdk_1.AccountId.fromString(parsedInput.senderAccountId),
                receiverId: this.hederaKit.client.operatorAccountId
            });
            await this.hederaKit.claimAirdrop(airdropId);
            return JSON.stringify({
                status: "success",
                message: "Airdrop claim successful",
                tokenId: parsedInput.tokenId,
                senderAccountId: parsedInput.senderAccountId,
                receiverAccountId: sdk_1.AccountId.fromString(process.env.HEDERA_ACCOUNT_ID)
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaClaimAirdropTool = HederaClaimAirdropTool;
class HederaGetPendingAirdropTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_get_pending_airdrop';
        this.description = `Get the pending airdrop for a token on Hedera
Inputs ( input is a JSON string ):
- accountId: string, the account ID to get the pending airdrop for e.g. 0.0.789012,
Example usage:
1. Get the pending airdrop for account 0.0.789012:
  '{
    "accountId": "0.0.789012"
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const airdrop = await this.hederaKit.getPendingAirdrops(parsedInput.accountId, process.env.HEDERA_NETWORK);
            return JSON.stringify({
                status: "success",
                message: "Pending airdrop retrieved",
                airdrop: airdrop
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaGetPendingAirdropTool = HederaGetPendingAirdropTool;
class HederaGetAllTokenBalancesTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_get_all_token_balances';
        this.description = `Get all token balances for an account on Hedera
Inputs ( input is a JSON string ):
accountId : string, the account ID to get the token balances for e.g. 0.0.789012,
- **accountId** (*string*, optional): The Hedera account ID to check the balance for (e.g., "0.0.789012").  
  - If omitted, the tool will return the balance of the connected account.  

Example usage:
1. Get all token balances for account 0.0.789012:
  '{
    "accountId": "0.0.789012"
  }'
2. Get all token balances for the connected account:
   '{}'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const balances = await this.hederaKit.getAllTokensBalances(process.env.HEDERA_NETWORK, parsedInput.accountId);
            return JSON.stringify({
                status: "success",
                message: "Token balances retrieved",
                balances: balances
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaGetAllTokenBalancesTool = HederaGetAllTokenBalancesTool;
class HederaGetTokenHoldersTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_get_token_holders';
        this.description = `Get the holders of a token on Hedera
Inputs ( input is a JSON string ):
tokenId: string, the ID of the token to get the holders for e.g. 0.0.123456,
threshold (optional): number, the threshold of the token to get the holders for e.g. 100,
Example usage:
1. Get the holders of token 0.0.123456 with a threshold of 100:
  '{
    "tokenId": "0.0.123456",
    "threshold": 100
  }
}
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const holders = await this.hederaKit.getTokenHolders(parsedInput.tokenId, parsedInput.threshold);
            return JSON.stringify({
                status: "success",
                message: "Token holders retrieved",
                holders: holders
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaGetTokenHoldersTool = HederaGetTokenHoldersTool;
class HederaCreateTopicTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_create_topic';
        this.description = `Create a topic on Hedera
Inputs ( input is a JSON string ):
name: string, the name of the topic e.g. My Topic,
isSubmitKey: boolean, decides whether submit key should be set, false if not passed
Example usage:
1. Create a topic with name "My Topic" and submit key:
  '{
    "name": "My Topic",
    "isSubmitKey": true
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const topic = await this.hederaKit.createTopic(parsedInput.name, parsedInput.isSubmitKey);
            return JSON.stringify({
                status: "success",
                message: "Topic created",
                topic: topic
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaCreateTopicTool = HederaCreateTopicTool;
class HederaDeleteTopicTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_delete_topic';
        this.description = `Delete a topic on Hedera
Inputs ( input is a JSON string ):
topicId: string, the ID of the topic to delete e.g. 0.0.123456,
Example usage:
1. Delete topic 0.0.123456:
  '{
    "topicId": "0.0.123456"
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.deleteTopic(sdk_1.TopicId.fromString(parsedInput.topicId));
            return JSON.stringify({
                status: "success",
                message: "Topic deleted",
                topicId: parsedInput.topicId
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaDeleteTopicTool = HederaDeleteTopicTool;
class HederaSubmitTopicMessageTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_submit_topic_message';
        this.description = `Submit a message to a topic on Hedera
Inputs ( input is a JSON string ):
topicId: string, the ID of the topic to submit the message to e.g. 0.0.123456,
message: string, the message to submit to the topic e.g. "Hello, Hedera!"
Example usage:
1. Submit a message to topic 0.0.123456:
  '{
    "topicId": "0.0.123456",
    "message": "Hello, Hedera!"
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            await this.hederaKit.submitTopicMessage(sdk_1.TopicId.fromString(parsedInput.topicId), parsedInput.message);
            return JSON.stringify({
                status: "success",
                message: "Message submitted",
                topicId: parsedInput.topicId,
                topicMessage: parsedInput.message
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaSubmitTopicMessageTool = HederaSubmitTopicMessageTool;
class HederaGetTopicInfoTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_get_topic_info';
        this.description = `Get information about a topic on Hedera
Inputs ( input is a JSON string ):
topicId: string, the ID of the topic to get the information for e.g. 0.0.123456,
Example usage:
1. Get information about topic 0.0.123456:
  '{
    "topicId": "0.0.123456"
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const topicInfo = await this.hederaKit.getTopicInfo(sdk_1.TopicId.fromString(parsedInput.topicId), this.hederaKit.client.network.type);
            return JSON.stringify({
                status: "success",
                message: "Topic information retrieved",
                topicInfo: topicInfo
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaGetTopicInfoTool = HederaGetTopicInfoTool;
class HederaGetTopicMessagesTool extends tools_1.Tool {
    constructor(hederaKit) {
        super();
        this.hederaKit = hederaKit;
        this.name = 'hedera_get_topic_messages';
        this.description = `Get messages from a topic on Hedera within an optional time range.

Inputs (input is a JSON string):
- topicId: string, the ID of the topic to get the messages from e.g. "0.0.123456"
- lowerThreshold: string (optional), ISO date string for the start of the time range e.g. "2025-01-02T00:00:00.000Z"
- upperThreshold: string (optional), ISO date string for the end of the time range e.g. "2025-01-20T12:50:30.123Z"

Example usage:
1. Get all messages from topic 0.0.123456:
  '{
    "topicId": "0.0.123456"
  }'

2. Get messages from topic after January 2, 2025:
  '{
    "topicId": "0.0.123456",
    "lowerThreshold": "2025-01-02T00:00:00.000Z"
  }'

3. Get messages between two dates: 2024-03-05T13:40:00.000Z and 2025-01-20T12:50:30.123Z
  '{
    "topicId": "0.0.123456", 
    "lowerThreshold": "2024-03-05T13:40:00.000Z",
    "upperThreshold": "2025-01-20T12:50:30.123Z"
  }'
`;
    }
    async _call(input) {
        try {
            const parsedInput = JSON.parse(input);
            const messages = await this.hederaKit.getTopicMessages(sdk_1.TopicId.fromString(parsedInput.topicId), parsedInput.lowerThreshold, parsedInput.upperThreshold);
            return JSON.stringify({
                status: "success",
                message: "Topic messages retrieved",
                messages: messages
            });
        }
        catch (error) {
            return JSON.stringify({
                status: "error",
                message: error.message,
                code: error.code || "UNKNOWN_ERROR",
            });
        }
    }
}
exports.HederaGetTopicMessagesTool = HederaGetTopicMessagesTool;
function createHederaTools(hederaKit) {
    return [
        new HederaCreateFungibleTokenTool(hederaKit),
        new HederaTransferTokenTool(hederaKit),
        new HederaGetBalanceTool(hederaKit),
        new HederaAirdropTokenTool(hederaKit),
        new HederaCreateNonFungibleTokenTool(hederaKit),
        new HederaGetHtsBalanceTool(hederaKit),
        new HederaAssociateTokenTool(hederaKit),
        new HederaDissociateTokenTool(hederaKit),
        new HederaRejectTokenTool(hederaKit),
        new HederaMintFungibleTokenTool(hederaKit),
        new HederaTransferHbarTool(hederaKit),
        new HederaMintNFTTool(hederaKit),
        new HederaClaimAirdropTool(hederaKit),
        new HederaGetPendingAirdropTool(hederaKit),
        new HederaGetAllTokenBalancesTool(hederaKit),
        new HederaGetTokenHoldersTool(hederaKit),
        new HederaCreateTopicTool(hederaKit),
        new HederaDeleteTopicTool(hederaKit),
        new HederaSubmitTopicMessageTool(hederaKit),
        new HederaGetTopicInfoTool(hederaKit),
        new HederaGetTopicMessagesTool(hederaKit)
    ];
}
//# sourceMappingURL=index.js.map