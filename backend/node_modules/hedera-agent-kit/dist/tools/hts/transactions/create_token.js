"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create_token = void 0;
const sdk_1 = require("@hashgraph/sdk");
const create_token = async (options) => {
    const tx = new sdk_1.TokenCreateTransaction()
        .setTokenName(options.name)
        .setTokenSymbol(options.symbol)
        .setTokenType(options.tokenType)
        .setDecimals(options.decimals || 0)
        .setInitialSupply(options.initialSupply || 0)
        .setTreasuryAccountId(options.client.operatorAccountId);
    // Optional and conditional parameters
    if (options.maxSupply) {
        tx.setMaxSupply(options.maxSupply).setSupplyType(sdk_1.TokenSupplyType.Finite);
    }
    if (options.tokenMetadata) {
        tx.setMetadata(options.tokenMetadata);
    }
    if (options.memo) {
        tx.setTokenMemo(options.memo);
    }
    if (options.isMetadataKey) {
        tx.setMetadataKey(options.client.operatorPublicKey);
    }
    if (options.isSupplyKey) {
        tx.setSupplyKey(options.client.operatorPublicKey);
    }
    if (options.isAdminKey) {
        tx.setAdminKey(options.client.operatorPublicKey);
    }
    const txResponse = await tx.execute(options.client);
    const receipt = await txResponse.getReceipt(options.client);
    const txStatus = receipt.status;
    if (!receipt.tokenId)
        throw new Error("Token Create Transaction failed");
    return {
        status: txStatus.toString(),
        txHash: txResponse.transactionId.toString(),
        tokenId: receipt.tokenId,
    };
};
exports.create_token = create_token;
//# sourceMappingURL=create_token.js.map