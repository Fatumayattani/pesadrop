"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sdk_1 = require("@hashgraph/sdk");
const tools_1 = require("../tools");
class HederaAgentKit {
    constructor(accountId, privateKey, network = 'mainnet') {
        // @ts-ignore
        this.client = sdk_1.Client.forNetwork(network).setOperator(accountId, privateKey);
    }
    async createFT(options) {
        return (0, tools_1.create_token)({
            ...options,
            tokenType: sdk_1.TokenType.FungibleCommon,
            client: this.client,
        });
    }
    async createNFT(options) {
        return (0, tools_1.create_token)({
            ...options,
            decimals: 0,
            initialSupply: 0,
            isSupplyKey: true,
            tokenType: sdk_1.TokenType.NonFungibleUnique,
            client: this.client,
        });
    }
    async transferToken(tokenId, toAccountId, amount) {
        return (0, tools_1.transfer_token)(tokenId, toAccountId, amount, this.client);
    }
    async getHbarBalance(accountId) {
        const targetAccountId = accountId || this.client.operatorAccountId;
        return (0, tools_1.get_hbar_balance)(this.client, targetAccountId);
    }
    async getHtsBalance(tokenId, networkType, accountId) {
        const targetAccountId = accountId || this.client.operatorAccountId;
        return (0, tools_1.get_hts_balance)(tokenId, networkType, targetAccountId);
    }
    async getAllTokensBalances(networkType, accountId) {
        const targetAccountId = accountId || this.client.operatorAccountId;
        return (0, tools_1.get_all_tokens_balances)(networkType, targetAccountId);
    }
    async getHtsTokenDetails(tokenId, networkType) {
        return (0, tools_1.get_hts_token_details)(tokenId, networkType);
    }
    async getTokenHolders(tokenId, networkType, threshold) {
        return (0, tools_1.get_token_holders)(tokenId.toString(), networkType, threshold);
    }
    async associateToken(tokenId) {
        return (0, tools_1.associate_token)(tokenId, this.client);
    }
    async dissociateToken(tokenId) {
        return (0, tools_1.dissociate_token)(tokenId, this.client);
    }
    async airdropToken(tokenId, recipients) {
        return (0, tools_1.airdrop_token)(tokenId, recipients, this.client);
    }
    async rejectToken(tokenId) {
        return (0, tools_1.reject_token)(tokenId, this.client);
    }
    async mintToken(tokenId, amount) {
        return (0, tools_1.mint_token)(tokenId, amount, this.client);
    }
    async mintNFTToken(tokenId, tokenMetadata) {
        return (0, tools_1.mint_nft)(tokenId, tokenMetadata, this.client);
    }
    async transferHbar(toAccountId, amount) {
        return (0, tools_1.transfer_hbar)(this.client, toAccountId, amount);
    }
    async claimAirdrop(airdropId) {
        return (0, tools_1.claim_airdrop)(this.client, airdropId);
    }
    async getPendingAirdrops(accountId, networkType) {
        return (0, tools_1.get_pending_airdrops)(networkType, accountId);
    }
    async createTopic(topicMemo, isSubmitKey) {
        return (0, tools_1.create_topic)(topicMemo, this.client, isSubmitKey);
    }
    async deleteTopic(topicId) {
        return (0, tools_1.delete_topic)(topicId, this.client);
    }
    async getTopicInfo(topicId, networkType) {
        return (0, tools_1.get_topic_info)(topicId, networkType);
    }
    async submitTopicMessage(topicId, message) {
        return (0, tools_1.submit_topic_message)(topicId, message, this.client);
    }
    async getTopicMessages(topicId, networkType, lowerTimestamp, upperTimestamp) {
        return (0, tools_1.get_topic_messages)(topicId, networkType, lowerTimestamp, upperTimestamp);
    }
    async approveAssetAllowance(spenderAccount, amount, tokenId) {
        return (0, tools_1.approve_asset_allowance)(spenderAccount, tokenId, amount, this.client);
    }
}
exports.default = HederaAgentKit;
//# sourceMappingURL=index.js.map